## HTTP相关问题

超⽂本传输协议，超文本，传输，协议。

这是一个双向传输的协议。

### 常见状态码

| code | 含义                                     | 常见               |
| ---- | ---------------------------------------- | ------------------ |
| 1XX  | 提示信息，标识处于中间状态，需要后续操作 |                    |
| 2XX  | 成功，报文被收到并被正确的处理           | 200，204，206      |
| 3XX  | 重定向，资源位置变动，需要重新请求       | 301，302，304      |
| 4XX  | 客户端错误，报文错误，无法处理           | 400，403，404      |
| 5XX  | 服务器错误，服务器在处理请求的时候内部错 | 500，501，502，503 |

+ 「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
+ 「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据
+ 「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的⼀部分，也是服务器处理成功的状态。

+ 「301 Moved Permanently」表示永久定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。
+ 「302 Found」表示临时定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。
+ 301 和 302 都会在响应头⾥使⽤字段  `Location`，指明后续要跳转的 URL，浏览器会⾃动定向新的 URL。
+ 304 Not Modified 不具有跳转的含义，表示资源未修改，定向已存在的缓冲⽂件，也称缓存定向，⽤于缓 存控制。

接下来是错误报文

1. 「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。
2. 「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。
3. 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

`5xx`类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。

+ 「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。 
+ 「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。
+ 「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器 发生了错误。
+ 「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后试”的意 思。

### 常见字段

1. host(www.baidu.com)

   > 有了 Host 字段，就可以将请求发往「同⼀台」服务器上的不同⽹站。

2. Content-Length字段

   > 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。他会告诉浏览器当前返回信息的长度信息。

3. Connection字段

   > 最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复用。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive 。

4. Content-Type字段

   > Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。
   >
   > 如：`Content-Type: text/html; charset=utf-8` #发送的是⽹⻚，⽽且编码是UTF-8。
   >
   > 客户端请求的时候，可以使⽤     Accept 字段声明⾃⼰可以接受哪些数据格式。
   >
   > `Accept: */*`

5. Content-Encoding字段

   > 数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式
   >
   > `Content-Encoding: gzip`
   >
   > 客户端在请求时，⽤     Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。
   >
   > `Accept-Encoding: gzip, deflate`

### GET AND POST

#### 区别

get从服务端获取资源，类型多样。post向指定的资源提交数据，放在报文的body中。

#### 安全问题

先说明下安全和幂等的概念：

1. 在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。
2. 所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。

get属于只读的，显而易见。而post可能带来资源的修改

### HTTP特性

首先http很灵活，可以自定义和扩展部分内容。

但是http时无状态的，在处理关联操作的时候可能需要引入cookies等得到用户的信息，

且http是明文传输的，所以一些信息需要进行加密之后再传输。

最后http最严重的问题就是安全问题：

+ 不验证通信⽅的身份，因此有可能遭遇伪装
+ ⽆法证明报⽂的完整性，所以有可能已遭篡改。

HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极致。

在http1.1上引入了两个新特性：

1. 长连接
2. 管道网络传输

1 长连接

早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是 串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的复建⽴和断开所造成的额外开销，减轻了服务器端的负载

持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。

2 管道⽹络传输

HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。

即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第 ⼆个请求出去，可以减少整体的响应时间。

举例来说，客户端需要请求两个资源。以前的做法是，在同⼀个TCP连接⾥⾯，先发送 A 请求，然后等待服务器做 出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求 排队等着。这称为「队头堵塞」。

这也是一把双刃剑，这个模式加剧了性能问题。

### HTTPS

#### HTTP2

+ HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。

+ HTTPS 在 TCP 三次握⼿之 后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。

+ HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

关于SSK/TLS流程问题：

1. 客户端向服务器索要并验证服务器的公钥。
2. 双⽅协商⽣产「会话秘钥」。
3. 双⽅采⽤「会话秘钥」进⾏加密通信。

反思HTTP1.1的性能瓶颈：

+ 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩Body 的部分； 
+ 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；
+ 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞； 
+ 没有请求优先级控制；
+ 请求只能从客户端开始，服务器只能被动响应。

HTTP2做了优化的部分，HTTP2是基于https的。

**1 头部压缩**

HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重 复的部分。

这就是所谓的HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。

**2 二进制格式**

HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并 且统称为帧（frame）：头信息帧和数据帧。

**3 数据流**

HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据 包做标记，指出它属于哪个回应。

每个请求或回应的所有数据包，称为⼀个数据流（   Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规 定客户端发出的数据流编号为奇数，  服务器发出的数据流编号为偶数

客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。

**4 多路复用**

HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。

移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼ 了连接的利⽤率

举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就 回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

**5 服务器推送**

HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发 送消息。

举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减 少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）

#### HTTP3

HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等 待这个丢了的包被重传回来。

这都是基于 TCP 传输层的问题，所以  HTTP/3 把 HTTP 下层的 TCP 协议改成了UDP！

UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞和HTTP/2 的⼀个丢包全部传问题。

实现上做了一个UDP的可靠传输QUIC

