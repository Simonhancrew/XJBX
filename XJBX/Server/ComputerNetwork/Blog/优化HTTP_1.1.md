## 优化HTTP/1.1

目前主要考虑：

1. 短链接改长连接
2. 尽量避免发送http请求（缓存）
3. 在需要的时候，怎么减少请求的次数 (减少重定向的次数，合并请求，延迟发送请求)
4. 减少服务器http响应的数据大小（压缩）

### 避免发送

万金油，缓存

有些重复请求，每次数据都一样，这种就没必要了，我们把请求保存在本地一份，下次直接读本地的。

通过缓存技术，HTTP 协议的头部有不少是针对缓存的字段，设计者也想到了这一点。

客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽响应作为 value，两者形成映射关系。后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，找到了直接从本地读。

这里也存在一个问题，如何确保这个缓存时最新的？过期时间，发送的时候把这个加到响应头中，发现过期的话直接重发就行了。

### 减少请求次数

1. 减少定向请求次数
2. 合并请求
3. 延迟发送请求

首先，关于重定向，服务器上的⼀个资源可能由于迁移、维护等原因从 url1 移⾄ url2 后，⽽客户端不知情，它还是继续请求 url1，这 时服务器不能粗暴地返回错误，⽽是通过     302 响应码和     Location 头部，告诉客户端该资源已经迁移⾄ url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。重定向越多，请求次数越多，性能越低

解决方法就是设置一个代理服，重定向由代理服安排。

其次，合并请求，把多个访问⼩⽂件的请求合并成⼀个⼤的请求，传输资源一样，但是请求减少，等价于优化了性能。

另外由于 HTTP/1.1 是请求响应模型，如果第⼀个发送的请求，未收到对应的响应，那么后续的请求就不会发送， 于是为了防⽌单个请求的阻塞，所以⼀般浏览器会同时发起 5-6 个请求，每⼀个请求都是不同的 TCP 连接，那么 如果合并了请求，也就会减少 TCP连接的数量，因⽽省去了TCP 握⼿和慢启动过程耗费的时间。

另外关于图片，很多都是打包发的，还可以通过base64编码之后打到html中一起发过来，不必再请求图片发送了。资源变大，这也会带来一些网络上的要求。

最后，延迟发送，简单的讲，当前用不到的就别发了，我这里按需要获取，不要的你先别发给我。

### 减少响应数据的大小

+ 无损压缩
+ 有损压缩

gzip 就是⽐较常⻅的⽆损压缩。客户端⽀持的压缩算法，会在 HTTP 请求中通过头部中的 Accept-Encoding 字段告诉服务器：

```
Accept-Encoding: gzip, deflate, br
```

服务端收到之后会选择压缩算法，通过响应头部回传

```
content-encoding: gzip
```

另外有损压缩是信息损失的，但是可以选择损失程度,这里可以通过q 质因⼦告诉服务端能够接受的质量下限

```
Accept: audio/*; q=0.2, audio/basic
```

