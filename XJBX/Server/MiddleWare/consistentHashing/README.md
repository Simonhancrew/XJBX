## 一致性哈希算法的基本原理

### 0 问题分析

对于服务器集群的设计和实现数据缓存，以往常见的策略：

1. 无论是添加和删除数据，都先将数据的id通过哈希函数算成一个hash值。记为hash
2. 假设目前有N台机器，计算 hash % N 的值，这个值就是所属机器的编号。

但是这种方式在添加机器和删除机器的时候是很容易造成负载倾斜的，如果要让负载均衡的话，需要根据所有的id重新计算一次hash值，将hash值对新机器重新mod，这会带来巨大的代价，造成海量的数据迁移.

### 1 解决方式

下面是其中一种解决方法,一致性哈希算法,这是一种很不错的数据缓存设计方案.

首先我们假设数据能被hash函数映射到一个2<sup>32</sup>的范围内,我们设想成一个环,头尾相连,一个数据的hash出现在对应的环上的一个位置上.



此时我们假设有三台机器,计算出机器id的hash值,依照这个值去放置机器在环上.

对于一个数据而言,首先将该数据的id用hash函数算出,之后映射到环上的相对应位置,然后顺时针找到离这个位置最近的机器,那台机器就是该数据的归属.



增加机器的处理.加入有两台机器(m1,m2)和三个数据(data1,2,3),如果此时想要加入新的一台机器的话.

在没有添加m3之前,m1到m3这一段是m2掌控的,添加之后属于m3,同时要把这一段的数据从m2迁移到m3.(这里还没有加入均衡的处理),这样的代价就是一个环上片段的迁移.在删除机器的时候也是一样的,只要把删除的机器的数据全部赋值到顺时针的下一台机器上就可以了.



### 2 负载均衡的解决方式(虚拟节点)

上述所有的处理,存在一个尚未解决的问题,就是服务器数量较少的时候,我hash这些服务器是不一定均衡的.可能有的服务器会占到更多的环上区域,另外一些服务器占到的区域却很小的.



考虑解决这个问题的方式也很简单,引入虚拟节点的机制,即对每一台机器通过不同的哈希函数计算多个哈希值,对多个位置都放置一个服务器节点,称之为虚拟节点.

具体的做法可以通过在机器的ip地址或主机名后面增加编号或者端口来实现.

假设有m1,m2,两台机器,我各算出10w个节点放置在环上,某时刻一个请求id到来,我找到这个请求id在环上的位置,之后找到顺时针的第一个服务器,假定这个节点是m1-1,我们查表找到对应的真实服务器=>m1

根据哈希函数的性质,这样的平衡性会大大的改善.

总结的来说就是,我们给每台机器分配相当多的虚拟节点,去抢占这个环,数量多起来的时候,哈希函数的离散型就会得到很好的体现,然后每台机器就可以按照所占的虚拟节点的比例来分配负载了.这就是虚拟节点带来的优势.

